#哈希表法
# -*- coding:utf-8 -*-
from collections import Counter 
class Solution:
    # 返回[a,b] 其中ab是出现一次的两个数字
    def FindNumsAppearOnce(self, array):
        # write code here
        res = []
        c = Counter(array)
        for key, val in c.items():
            if val % 2 == 1:
                res.append(key)
            if len(res) == 2:
                return res
'''
 首先我们考虑这个问题的一个简单版本：一个数组里除了一个数字之外，其他的数字都出现了两次。请写程序找出这个只出现一次的数字。
 这个题目的突破口在哪里？题目为什么要强调有一个数字出现一次，其他的出现两次？我们想到了异或运算的性质：任何一个数字异或它自己都等于0 。也就是说，如果我们从头到尾依次异或数组中的每一个数字，那么最终的结果刚好是那个只出现一次的数字，因为那些出现两次的数字全部在异或中抵消掉了。
 有了上面简单问题的解决方案之后，我们回到原始的问题。如果能够把原数组分为两个子数组。在每个子数组中，包含一个只出现一次的数字，而其它数字都出现两次。如果能够这样拆分原数组，按照前面的办法就是分别求出这两个只出现一次的数字了。
 我们还是从头到尾依次异或数组中的每一个数字，那么最终得到的结果就是两个只出现一次的数字的异或结果。因为其它数字都出现了两次，在异或中全部抵消掉了。由于这两个数字肯定不一样，那么这个异或结果肯定不为0 ，也就是说在这个结果数字的二进制表示中至少就有一位为1 。我们在结果数字中找到第一个为1 的位的位置，记为第N 位。现在我们以第N 位是不是1 为标准把原数组中的数字分成两个子数组，第一个子数组中每个数字的第N 位都为1 ，而第二个子数组的每个数字的第N 位都为0 。
 现在我们已经把原数组分成了两个子数组，每个子数组都包含一个只出现一次的数字，而其它数字都出现了两次。因此到此为止，所有的问题我们都已经解决。'''

'''
二进制

二进制是计算机中一种常用的计数系统，也是现代计算机的基石，计算机中的所有信息都是以二进制形式表示的，而计算机的一切操作也都是以二进制进行的。因此学习和掌握二进制及其相关运算，对理解计算机工作原理以及优化算法具有重要意义。

位运算

由于计算机中数据都是以二进制的形式存在的，那么对二进制位进行直接操作，必定能够使算法更为高效，位运算便应运而生。

位运算的基本类型

按位与：两个位都为1时，结果才为1

按位或：两个位都为0时，结果才为0

按位异或：两个位相同时，结果为1，否则结果为0

取反：对各个位分别取反（0变为1，1变为0）

左移：将各二进制位左移若干位，高位（左边）舍弃，低位（右边）补0

右移：将各二进制位右移若干位，低位（右边）舍弃，正数时高位（左边）补0，负数时高位（左边）补1

位运算的性质

按位与：

与0相与清零。想将指定位上的数清零，只需与一个相应指定位上为0的数相与即可。

与1想与保留原值。想获取（或保留）指定位上的数，只需找一个相应指定位为1，其余位为0的数相与即可

如：将10111100 11011111的低八位清零 高八位保留，只需要将其与11111111 00000000相与即可

按位或：

与0相或保留原值

与1相或将指定位置置1

如：将10110010的低四位置为1，只需将其与1111相或即可，即：10110010|1111=10111111

按位异或：

与0异或保留原值

与1异或将指定位置翻转

如：将11001011低四位翻转，只需将其与1111相异或即可，即：11001011^1111=11000100

左移运算：

相当于将原数值乘以2（注意溢出）

右移运算：

相当于将原数值除以2

位运算的应用技巧

判断奇偶性

奇数的二进制数末位为1，偶数的二进制位末位为0，因此可以将给定的数与1相与，结果为0则为偶数

public static boolean isPower(int i) {
return (i & (i - 1)) == 0;
}

判断是否是2的整数幂

表1
由上表可以看出，要判断一个数是否是2的整数幂，只需将该数与该数减1相与，若结果为0，则说明这个数是2的整数次幂
将表1前几列累加得到表2，可以看出，每次进行运算n&(n-1)，都消掉一个"1"，因此只要计算当最终结果为0时执行的次数即可。

public static int countBit(int i) {
int count = 0;
while (i != 0) {
count++;
i &= i - 1;
}
return count;
}
最后附上最近使用位运算优化求解最大公约数的一个算法

public static int gcd(int a, int b) {
if (a == b) {
return a;
}
if (a < b) {
return gcd(b, a);
}
if (isEven(a) && isEven(b)) {
return gcd(a >> 1, b >> 1) << 1;
}
if (isEven(a) && !isEven(b)) {
return gcd(a >> 1, b);
}
if (!isEven(a) && isEven(b)) {
return gcd(a, b >> 1);
}
if (!isEven(a) && !isEven(b)) {
return gcd(b, a - b);
}
return -1;
}
'''
