# -*- coding:utf-8 -*-
class Solution:
    # 这里要特别注意~找到任意重复的一个值并赋值到duplication[0]
    # 函数返回True/False
    def duplicate(self, numbers, duplication):
        # write code here
        ns = []
        for i in numbers:
            if i < 0 or i > len(numbers)-1:
                return False
        for i in numbers:
            if i not in ns:
                ns.append(i)
            elif i in ns:
                duplication[0] = i 
                return True
        return False


'''
#检查数据的合法性
检查输入参数是否合法

数组中的数据是否满足所有数字都在0到n-1的范围内

#排序后判断重复
最简单的思路就是先把输入的数组排序。从排序的数组中找出重复的数字就是个很容易的事情了。只需要从头向尾扫描一遍排序好的数组即可。
对一个数组排序的时间复杂度是$O(nlogn)$
扫描一个排序好的数组发现重复的数字的时间复杂度是$O(n)$

##符号位标识法
我们可以看到数组中元素的大小都在[0-n)这个区间内, 都是正数，那么他们的符号位对我们来说就是无关紧要的, 因此我们直接拿符号位当成我们的标识位就行了

#固定偏移法
跟标识法类似, 如果不借助外部辅助空间，那么我们只能在数组内部下功夫，又能设置标识，又能恢复数据（不破坏数据）的方式，前面我们用符号位作为标识的方法就是通过符号位，
即判断了是否存在，又可以通过符号位的反转重新恢复数据，那么有没有其他类似的方法呢？
我们想到我们的数据都是[0, n)这个区间的，那么我们采用类似与移码的方法，让数据加上或者减去一个固定的偏移量，
这样就可以即标识数据，又不损坏数据,为了能够区分出数据，这个偏移必须大于N，这样我们的原数据与标识数据存在一一映射关系。
[0, n-1] -=>+偏移n-=> [n, 2n-1]

#将元素放在自己改在的位置
剑指offer上提供的方法，这种方法采用交换的方法
我们考虑如果每个数字都置出现一次，那么此时是最完美的，每一个下标i对应元素numbers[i]，也就是说我们对于数组中的每个元素numbers[i]都把它放在自己应该在的位置上numbers[numbers[i]]上, 
如果我们发现有两个元素想往同一个位置上放的时候，说明此元素必然重复
即如下的过程
如果numbers[i] == i, 那么我们认为number[i]这个元素是在自己的位置上的
否则的话, numbers[i]这个元素就应该在numbers[numbers[i]]这个位置上, 于是我们交换numbers[i]和numbers[numbers[i]]
重复操作1, 直到number[i]== i, 则继续操作下一个位置的元素, 或者numbers[i] == numbers[numbers[i]，元素重复
'''
